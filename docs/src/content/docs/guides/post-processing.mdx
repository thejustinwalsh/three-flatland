---
title: Post-Processing
description: Apply full-screen retro display effects using TSL nodes.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

three-flatland includes a collection of TSL nodes for simulating retro displays and applying post-processing effects. These work with Three.js's `PostProcessing` class to apply effects to the entire scene.

## Basic Setup

Post-processing requires setting up a `PostProcessing` instance and a scene pass:

<Tabs syncKey="framework">
  <TabItem label="Three.js" icon="seti:javascript">
    ```typescript
    import { WebGPURenderer, PostProcessing } from 'three/webgpu';
    import { pass } from 'three/tsl';
    import { uv } from 'three/tsl';
    import { Flatland, crtComplete } from '@three-flatland/core';

    // Create Flatland instance
    const flatland = new Flatland({
      viewSize: 300,
      clearColor: 0x1a1a2e,
    });

    // Set up post-processing
    const postProcessing = new PostProcessing(renderer);
    const scenePass = pass(flatland.scene, flatland.camera);

    // Apply CRT effect
    postProcessing.outputNode = crtComplete(scenePass, uv(), {
      curvature: 0.15,
      scanlineIntensity: 0.15,
    });

    // Connect to Flatland
    flatland.setPostProcessing(postProcessing, scenePass);

    // In render loop — flatland.render() updates batches + renders via post-processing
    function animate() {
      flatland.render(renderer);
      requestAnimationFrame(animate);
    }
    ```
  </TabItem>
  <TabItem label="React" icon="seti:react">
    ```tsx
    import { useEffect, useRef } from 'react';
    import { extend, useThree, useFrame } from '@react-three/fiber/webgpu';
    import { Flatland, Sprite2D, crtComplete } from '@three-flatland/react';

    extend({ Flatland, Sprite2D });

    function FlatlandScene() {
      const { gl, size } = useThree();
      const flatlandRef = useRef<Flatland>(null);

      // Add CRT effect — Flatland auto-creates PostProcessing on first render
      useEffect(() => {
        flatlandRef.current?.addEffect((input, uv) =>
          crtComplete(input, uv, { curvature: 0.15, scanlineIntensity: 0.15 })
        );
        return () => { flatlandRef.current?.clearEffects(); };
      }, []);

      useEffect(() => {
        flatlandRef.current?.resize(size.width, size.height);
      }, [size.width, size.height]);

      // flatland.render() handles batch updates + post-processing
      useFrame(() => {
        flatlandRef.current?.render(gl);
      }, 1);

      return (
        <flatland ref={flatlandRef} viewSize={300} clearColor={0x1a1a2e}>
          {/* sprites go here */}
        </flatland>
      );
    }
    ```
  </TabItem>
</Tabs>

## Display Effect Nodes

### CRT Effects

Simulate classic CRT television displays:

```typescript
import {
  crtComplete,
  crtCurvature,
  crtVignette,
  crtBloom,
  scanlines,
  phosphorMask,
} from '@three-flatland/core';

// All-in-one CRT effect (options object)
const crt = crtComplete(scenePass, uv(), {
  curvature: 0.15,           // Screen curvature amount
  vignetteIntensity: 0.3,    // Edge darkening
  scanlineIntensity: 0.15,   // Scanline visibility
  scanlineRes: 240,          // Scanline resolution
});

// Or compose individual effects (positional parameters)
const curvedUV = crtCurvature(uv(), 0.15);
const withScanlines = scanlines(scenePass, uv(), 240, 0.2);
```

### LCD Effects

Simulate LCD and handheld displays. All LCD functions use positional parameters:

```typescript
import {
  lcdGrid,
  lcdGBC,
  dotMatrix,
  dmgPalette,
} from '@three-flatland/core';

// LCD pixel grid: (inputColor, uv, resolution?, gridIntensity?, subpixelIntensity?)
const lcd = lcdGrid(scenePass, uv(), 240, 0.15, 0.1);

// Game Boy Color LCD: (inputColor, uv, resolution?, gridIntensity?)
const gbc = lcdGBC(scenePass, uv(), 160, 0.2);

// Game Boy DMG (4-color green palette + dot matrix)
// dmgPalette: (inputColor, contrast?)
// dotMatrix: (inputColor, uv, resolution?, dotSize?, backgroundColor?)
const dmg = dotMatrix(dmgPalette(scenePass), uv(), 160, 0.7, [0.5, 0.6, 0.4]);
```

### Phosphor Masks

Add RGB subpixel patterns:

```typescript
import { phosphorMask } from '@three-flatland/core';

// phosphorMask(inputColor, uv, maskType?, resolution?, intensity?)
// maskType: 'aperture' | 'slot' | 'shadow' (default: 'aperture')
const withPhosphor = phosphorMask(scenePass, uv(), 'aperture', 640, 0.15);
```

## Analog Video Effects

### VHS/Tape Effects

```typescript
import {
  vhsDistortion,
  staticNoise,
  chromaticAberration,
} from '@three-flatland/core';
import { uniform } from 'three/tsl';

const timeUniform = uniform(0);

// VHS tracking distortion: (tex, uv, time, intensity?, noiseAmount?)
const distorted = vhsDistortion(scenePass, uv(), timeUniform, 0.02, 0.1);

// Static noise overlay: (inputColor, uv, time, intensity?)
const noisy = staticNoise(distorted, uv(), timeUniform, 0.08);

// RGB channel separation: (tex, uv, amount?, angle?)
const final = chromaticAberration(noisy, uv(), 0.003);

// In animation loop, update time
timeUniform.value += delta;
```

## Film Effects

```typescript
import { filmGrain, vignette } from '@three-flatland/core';

// Film grain: (inputColor, uv, time, intensity?, luminanceInfluence?)
const grained = filmGrain(scenePass, uv(), timeUniform, 0.15, 0.3);

// Vignette (edge darkening): (inputColor, uv, intensity?, softness?, roundness?)
const final = vignette(grained, uv(), 0.6, 0.5);
```

## Console Palettes

Reduce colors to classic console palettes:

```typescript
import {
  dmgPalette,     // Game Boy (4 greens)
  gbcPalette,     // Game Boy Color
  snesPalette,    // SNES (15-bit)
  cgaPalette,     // CGA (4 colors)
  c64Palette,     // Commodore 64
} from '@three-flatland/core';

// Apply Game Boy palette: (inputColor, contrast?)
const gameboy = dmgPalette(scenePass);

// Combine with dot matrix for authentic look
const authentic = dotMatrix(gameboy, uv(), 160, 0.7);
```

## Combining Effects

Chain multiple effects together for complex looks:

```typescript
import { uniform } from 'three/tsl';
import {
  scanlines,
  phosphorMask,
  vignette,
  filmGrain,
} from '@three-flatland/core';

const timeUniform = uniform(0);

// Build effect chain
let output = scenePass;

// Add phosphor mask: (inputColor, uv, maskType?, resolution?, intensity?)
output = phosphorMask(output, uv(), 'aperture', 640, 0.1);

// Add scanlines: (inputColor, uv, resolution?, intensity?, offset?)
output = scanlines(output, uv(), 240, 0.15, timeUniform.mul(0.5));

// Add grain: (inputColor, uv, time, intensity?, luminanceInfluence?)
output = filmGrain(output, uv(), timeUniform, 0.05);

// Final vignette: (inputColor, uv, intensity?, softness?, roundness?)
output = vignette(output, uv(), 0.4, 0.5);

postProcessing.outputNode = output;
```

## Switching Effects at Runtime

When changing `outputNode` at runtime, you must set `needsUpdate = true` to trigger shader recompilation:

```typescript
type EffectType = 'none' | 'crt' | 'vhs' | 'lcd';

const effects: Record<EffectType, () => TSLNode> = {
  none: () => scenePass,
  crt: () => crtComplete(scenePass, uv(), { curvature: 0.15 }),
  vhs: () => vhsDistortion(scenePass, uv(), timeUniform, 0.02, 0.1),
  lcd: () => lcdGrid(scenePass, uv(), 240, 0.15, 0.1),
};

function setEffect(effect: EffectType) {
  postProcessing.outputNode = effects[effect]();
  postProcessing.needsUpdate = true; // Required for shader recompilation
}

// Switch effects
setEffect('crt');
```

## Performance Tips

- Post-processing adds GPU overhead - use sparingly on mobile
- Animated effects (noise, grain) need time uniforms updated each frame
- Combine effects judiciously - each adds shader complexity
- Test on target hardware to verify performance

## Next Steps

- [2D Lighting](/guides/lighting) - Dynamic lighting for sprites
- [TSL Nodes](/guides/tsl-nodes) - Per-sprite shader effects
- [Post-Processing Example](/examples/post-processing) - Interactive demo
