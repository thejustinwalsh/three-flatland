---
title: Post-Processing
description: Apply full-screen retro display effects using TSL nodes.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

three-flatland includes a collection of TSL nodes for simulating retro displays and applying post-processing effects. These work with Three.js's `PostProcessing` class to apply effects to the entire scene.

## Basic Setup

Post-processing requires setting up a `PostProcessing` instance and a scene pass:

<Tabs syncKey="framework">
  <TabItem label="Three.js" icon="seti:javascript">
    ```typescript
    import { WebGPURenderer, PostProcessing } from 'three/webgpu';
    import { pass } from 'three/tsl';
    import { uv } from 'three/tsl';
    import { Flatland, crtComplete } from '@three-flatland/core';

    // Create Flatland instance
    const flatland = new Flatland({
      viewSize: 300,
      clearColor: 0x1a1a2e,
    });

    // Set up post-processing
    const postProcessing = new PostProcessing(renderer);
    const scenePass = pass(flatland.scene, flatland.camera);

    // Apply CRT effect
    postProcessing.outputNode = crtComplete(scenePass, uv(), {
      curvature: 0.15,
      scanlineIntensity: 0.15,
    });

    // In render loop
    function animate() {
      flatland.spriteGroup.update();
      postProcessing.render();
      requestAnimationFrame(animate);
    }
    ```
  </TabItem>
  <TabItem label="React" icon="seti:react">
    ```tsx
    import { useEffect, useRef } from 'react';
    import { useThree, useFrame } from '@react-three/fiber/webgpu';
    import { PostProcessing } from 'three/webgpu';
    import { pass, uv } from 'three/tsl';
    import { crtComplete } from '@three-flatland/react';

    function PostProcessingEffects() {
      const { gl, scene, camera } = useThree();
      const postProcessingRef = useRef<PostProcessing | null>(null);

      useEffect(() => {
        const postProcessing = new PostProcessing(gl);
        const scenePass = pass(scene, camera);

        postProcessing.outputNode = crtComplete(scenePass, uv(), {
          curvature: 0.15,
          scanlineIntensity: 0.15,
        });

        postProcessingRef.current = postProcessing;
        return () => postProcessing.dispose?.();
      }, [gl, scene, camera]);

      useFrame(() => {
        postProcessingRef.current?.render();
      }, 1);

      return null;
    }
    ```
  </TabItem>
</Tabs>

## Display Effect Nodes

### CRT Effects

Simulate classic CRT television displays:

```typescript
import {
  crtComplete,
  crtCurvature,
  crtVignette,
  crtBloom,
  scanlines,
  phosphorMask,
} from '@three-flatland/core';

// All-in-one CRT effect
const crt = crtComplete(scenePass, uv(), {
  curvature: 0.15,           // Screen curvature amount
  vignetteStrength: 0.3,     // Edge darkening
  scanlineIntensity: 0.15,   // Scanline visibility
  scanlineCount: 240,        // Number of scanlines
});

// Or compose individual effects
const curved = crtCurvature(scenePass, uv(), { amount: 0.15 });
const withScanlines = scanlines(curved, uv(), {
  count: 240,
  intensity: 0.2,
});
```

### LCD Effects

Simulate LCD and handheld displays:

```typescript
import {
  lcdGrid,
  lcdGBC,
  dotMatrix,
  dmgPalette,
} from '@three-flatland/core';

// LCD pixel grid
const lcd = lcdGrid(scenePass, uv(), {
  gridSize: 3,
  lineWidth: 0.2,
  lineColor: [0, 0, 0, 0.3],
});

// Game Boy Color LCD
const gbc = lcdGBC(scenePass, uv(), {
  gridSize: 3,
  subpixelBlend: 0.5,
  brightness: 1.1,
});

// Game Boy DMG (4-color green palette + dot matrix)
const dmg = dotMatrix(dmgPalette(scenePass), uv(), {
  gridSize: 3,
  dotSize: 0.7,
  dotColor: [0.6, 0.7, 0.5, 1],
  bgColor: [0.5, 0.6, 0.4, 1],
});
```

### Phosphor Masks

Add RGB subpixel patterns:

```typescript
import { phosphorMask } from '@three-flatland/core';

const withPhosphor = phosphorMask(scenePass, uv(), {
  type: 'aperture-grille',  // 'aperture-grille' | 'slot-mask' | 'shadow-mask'
  scale: 3,
  intensity: 0.15,
});
```

## Analog Video Effects

### VHS/Tape Effects

```typescript
import {
  vhsDistortion,
  staticNoise,
  chromaticAberration,
} from '@three-flatland/core';
import { uniform } from 'three/tsl';

const timeUniform = uniform(0);

// VHS tracking distortion
const distorted = vhsDistortion(scenePass, uv(), timeUniform, {
  trackingNoise: 0.02,
  jitter: 0.001,
  waveSpeed: 2.0,
});

// Static noise overlay
const noisy = staticNoise(distorted, uv(), timeUniform, {
  intensity: 0.08,
  flickerSpeed: 15,
});

// RGB channel separation
const final = chromaticAberration(noisy, uv(), {
  offsetR: [0.003, 0],
  offsetB: [-0.003, 0],
});

// In animation loop, update time
timeUniform.value += delta;
```

## Film Effects

```typescript
import { filmGrain, vignette } from '@three-flatland/core';

// Film grain
const grained = filmGrain(scenePass, uv(), timeUniform, {
  intensity: 0.15,
  luminanceThreshold: 0.3,
});

// Vignette (edge darkening)
const final = vignette(grained, uv(), {
  offset: 0.5,
  darkness: 0.6,
});
```

## Console Palettes

Reduce colors to classic console palettes:

```typescript
import {
  dmgPalette,     // Game Boy (4 greens)
  gbcPalette,     // Game Boy Color
  snesPalette,    // SNES (15-bit)
  cgaPalette,     // CGA (4 colors)
  c64Palette,     // Commodore 64
} from '@three-flatland/core';

// Apply Game Boy palette
const gameboy = dmgPalette(scenePass);

// Combine with dot matrix for authentic look
const authentic = dotMatrix(gameboy, uv(), { gridSize: 3 });
```

## Combining Effects

Chain multiple effects together for complex looks:

```typescript
import { uniform } from 'three/tsl';
import {
  crtCurvature,
  scanlines,
  phosphorMask,
  vignette,
  filmGrain,
} from '@three-flatland/core';

const timeUniform = uniform(0);

// Build effect chain
let output = scenePass;

// Apply curvature
output = crtCurvature(output, uv(), { amount: 0.1 });

// Add phosphor mask
output = phosphorMask(output, uv(), {
  type: 'aperture-grille',
  intensity: 0.1,
});

// Add scanlines
output = scanlines(output, uv(), {
  count: 240,
  intensity: 0.15,
  offset: timeUniform.mul(0.5), // Animated roll
});

// Add grain
output = filmGrain(output, uv(), timeUniform, {
  intensity: 0.05,
});

// Final vignette
output = vignette(output, uv(), {
  offset: 0.4,
  darkness: 0.5,
});

postProcessing.outputNode = output;
```

## Switching Effects at Runtime

```typescript
type EffectType = 'none' | 'crt' | 'vhs' | 'lcd';

const effects: Record<EffectType, () => TSLNode> = {
  none: () => scenePass,
  crt: () => crtComplete(scenePass, uv(), { curvature: 0.15 }),
  vhs: () => vhsDistortion(scenePass, uv(), timeUniform, {}),
  lcd: () => lcdGrid(scenePass, uv(), { gridSize: 3 }),
};

function setEffect(effect: EffectType) {
  postProcessing.outputNode = effects[effect]();
}

// Switch effects
setEffect('crt');
```

## Performance Tips

- Post-processing adds GPU overhead - use sparingly on mobile
- Animated effects (noise, grain) need time uniforms updated each frame
- Combine effects judiciously - each adds shader complexity
- Test on target hardware to verify performance

## Next Steps

- [2D Lighting](/guides/lighting) - Dynamic lighting for sprites
- [TSL Nodes](/guides/tsl-nodes) - Per-sprite shader effects
- [Post-Processing Example](/examples/post-processing) - Interactive demo
