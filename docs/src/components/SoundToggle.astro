---
/**
 * SoundToggle - Volume control for retro sound effects
 * Cycles through: mute -> low -> medium -> high -> mute
 * Shows disabled state until browser allows audio playback.
 * Uses pixelated volume icons and lazy-loads the sound system.
 */
import Icon from './Icon.astro';
---

<flatland-sound-toggle>
  <button
    type="button"
    class="sound-toggle"
    data-sound="none"
    aria-label="Enable sound"
  >
    <span class="icon icon-disabled"><Icon name="volume" size="1rem" /></span>
    <span class="icon icon-mute"><Icon name="volume-x" size="1rem" /></span>
    <span class="icon icon-low"><Icon name="volume-1" size="1rem" /></span>
    <span class="icon icon-medium"><Icon name="volume-2" size="1rem" /></span>
    <span class="icon icon-high"><Icon name="volume-3" size="1rem" /></span>
  </button>
</flatland-sound-toggle>

<script>
  import type { VolumeLevel } from '../scripts/sounds';

  class FlatlandSoundToggle extends HTMLElement {
    private button: HTMLButtonElement | null = null;
    private volumeLevel: VolumeLevel = 0;
    private soundsModule: typeof import('../scripts/sounds') | null = null;
    private audioInitialized: boolean = false;
    private unsubscribeAudioState: (() => void) | null = null;

    constructor() {
      super();
      this.button = this.querySelector('button');

      // Show disabled state initially
      this.updateIcon();

      // Lazy load sounds module first, then setup
      this.loadSoundsModule();

      this.button?.addEventListener('click', () => this.handleClick());
    }

    private async loadSoundsModule() {
      try {
        this.soundsModule = await import('../scripts/sounds');
        // Initialize volume level from storage
        this.soundsModule.initVolumeLevel();
        this.volumeLevel = this.soundsModule.getVolumeLevel();
        this.audioInitialized = this.soundsModule.isAudioInitialized();

        // Listen for audio state changes
        this.unsubscribeAudioState = this.soundsModule.onAudioStateChange((initialized) => {
          this.audioInitialized = initialized;
          this.updateIcon();
        });

        this.updateIcon();
        // Setup global sound event handlers
        this.soundsModule.setupSoundEvents();
        // Setup view transition support for SPA navigation
        this.soundsModule.setupViewTransitionSupport();
      } catch (e) {
        console.warn('Could not load sound module:', e);
      }
    }

    disconnectedCallback() {
      // Cleanup subscription when element is removed
      this.unsubscribeAudioState?.();
    }

    private async ensureAudioInitialized(): Promise<boolean> {
      if (this.audioInitialized) return true;
      if (!this.soundsModule) return false;

      const success = await this.soundsModule.initAudio();
      if (success) {
        this.audioInitialized = true;
      }
      return success;
    }

    private async handleClick() {
      if (!this.soundsModule) return;

      // Always init audio on click (this is a user gesture)
      const wasInitialized = this.audioInitialized;
      await this.ensureAudioInitialized();

      // If this was the first click that initialized audio from the sound toggle,
      // enable sound (don't stay muted - user explicitly clicked sound icon)
      if (!wasInitialized && this.audioInitialized) {
        // Get stored preference
        this.volumeLevel = this.soundsModule.getVolumeLevel();

        // If muted or no preference, set to low (user clicked icon to enable sound)
        if (this.volumeLevel === 0) {
          this.soundsModule.setVolumeLevel(1);
          this.volumeLevel = 1;
        }

        this.updateIcon();
        // Play feedback sound
        this.soundsModule.playToggleOn();
        return;
      }

      // Normal cycling behavior
      this.volumeLevel = this.soundsModule.cycleVolumeLevel();
      this.updateIcon();

      // Play feedback sound at new level (if not muted)
      if (this.volumeLevel > 0) {
        this.soundsModule.playToggleOn();
      }
    }

    private updateIcon() {
      const icons = {
        disabled: this.querySelector('.icon-disabled'),
        mute: this.querySelector('.icon-mute'),
        low: this.querySelector('.icon-low'),
        medium: this.querySelector('.icon-medium'),
        high: this.querySelector('.icon-high'),
      };

      // Hide all icons first
      Object.values(icons).forEach(icon => icon?.classList.remove('active'));

      // If audio isn't initialized, show disabled state
      if (!this.audioInitialized) {
        icons.disabled?.classList.add('active');
        this.button?.setAttribute('aria-label', 'Click to enable sound');
        return;
      }

      // Show the current level icon
      switch (this.volumeLevel) {
        case 0:
          icons.mute?.classList.add('active');
          break;
        case 1:
          icons.low?.classList.add('active');
          break;
        case 2:
          icons.medium?.classList.add('active');
          break;
        case 3:
          icons.high?.classList.add('active');
          break;
      }

      // Update aria-label
      const labels: Record<VolumeLevel, string> = {
        0: 'Volume: muted (click for low)',
        1: 'Volume: low (click for medium)',
        2: 'Volume: medium (click for high)',
        3: 'Volume: high (click to mute)',
      };
      this.button?.setAttribute('aria-label', labels[this.volumeLevel]);
    }
  }

  customElements.define('flatland-sound-toggle', FlatlandSoundToggle);
</script>

<style>
  flatland-sound-toggle {
    display: flex;
    align-items: center;
  }

  .sound-toggle,
  .sound-toggle:hover,
  .sound-toggle:focus,
  .sound-toggle:active {
    all: unset;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--retro-white);
  }

  .sound-toggle:hover {
    color: var(--retro-cyan);
  }

  .icon {
    display: none;
    align-items: center;
    justify-content: center;
    width: 1rem;
    height: 1rem;
    line-height: 0;
  }

  .icon.active {
    display: flex;
  }

  .icon :global(svg) {
    display: block;
  }

  /* Disabled state - audio not yet unlocked by browser */
  .icon-disabled {
    opacity: 0.5;
  }

  /* Muted state - pink to indicate intentionally off */
  .icon-mute {
    color: var(--retro-pink);
    opacity: 0.6;
  }

  /* Light mode */
  :global([data-theme='light']) .sound-toggle {
    color: var(--retro-black);
  }

  :global([data-theme='light']) .sound-toggle:hover {
    color: var(--retro-purple);
  }
</style>
